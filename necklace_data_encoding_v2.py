import numpy as np
# setup variables, don't touch
w = 0 			# used as a word counter
words = [[]] 		# stores words as they're used
puncuation = [] 	# stores puncuation (spacers) to match words
data = [] 		# binary data goes here
flags = [] 		# flags for data when reading encoded input
split = 0 			# true/false for splitting text up

# encoding variables, all must match for encoding AND decoding or text cannot be recovered easily
a, b, c = 13, 1, 1 		# a = necklace length (when not splitting), b = starting point, c = increase for each necklace check
                                    # a should be >= 11, b needs to be low enough to fit alphabet + spacers within the necklace space generated by a
alphabet  = [ "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
alphabet += ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",]
alphabet += ["@", "#", "$", "%", "^", "&", "*", "(", ")", "-", "_", "=", "+", "[", "]", "{", "}", "\\", "|", "'", '"', "<", ">", "/", "`", "~", ":", ";", "â€¦", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]
spacers = [" ", ".", ",", "!", "?", "\n"]

# code starts here

def splitText(): 					# split text
    w = 0 							# word counter
    p = 0 							# puncuation counter
    for char in text: 				# for each character
        #if char == "\n": 				# check if newline
            #continue 					# ignore it
        if char in spacers: 			# check if spacer
            if p == 0: 					# check if first puncuation
                ''.join(words[w]) 		# that means it was a full word
                words.append([]) 		# make space for the next word
                puncuation.append(char) 	# add the spacer to the puncuation list to match the word
                w += 1 					# add to the word counter
                p += 1 					# add to puncuation counter (ignores multiple spacers)
        else: 						# if not spacer (so found in alphabet)
            words[w].append(char) 		# add the character to the current word
            p = 0 						# reset puncuation counter

def generate(n): 									# function to generate uniques
    x = b 											# start at 1, avoid all 0s case
    while (x < 2**n): 								# for each possible number
        if len(uniques) > (len(alphabet) + len(spacers)): 	# check if enough already gnerated
            break 									# stop if enough already generated
        s = str(bin(x)[2:].zfill(n)) 						# get binary of number
        cycle = [] 									# get blank list to check rotations
        for i in range(len(s)//2 +1): 					# check rotations going both ways
            #rot = cycle[i][-1] + cycle[i][:-1] 				#slightly slower
            rot = s[i:] + s[:i] 							# rotate by i bits
            rotb = s[(len(s) - i):] + s[:(len(s) - i)] 			# reverse rotation, may help find smaller quicker
            cycle.append(rot) 							# add forward rotation
            cycle.append(rotb)							# add reverse rotation
            if rot < s or rotb < s : 						# if rotation found that is smaller
                break 									# stop searching
        if min(cycle) == s : 							# if the number is already minimum
            uniques.append(s) 							# add to the list
            #print(f'\t{s}') 							# print results (slow)
        x += 2 * c 									# count odds, halves time
    x=0
    #print(f'Alphabet {w}: ')
    for letter in alphabet:
        #print(f'\t{letter}\t{uniques[x]}')
        match.append([letter, uniques[x]])
        x+=1
    if function == 0:
        for spacer in spacers:
            match.append([spacer, uniques[x]])
            x+=1
    else:
        spc = []
        for spacer in spacers:
            spc.append([spacer, uniques[x]])
            x+=1
            for item in spc:
                if puncuation[w] in item:
                    puncuation[w] = item[0]
                    if function == 0:
                        data.append(randRot(str(item[1])))
    for item in match:
        for i in range(len(word)):
            if word[i] in item:
                word[i] = item[0]
    if function == 0:
        l = 1
    else:
        l = 0 #
    for i in range(len(word) + l):
        for item in match:
            if i < len(word):
                if word[i] in item:
                    #print(f'{item[0]}\t{item[1]}\tK = {i+1}')
                    if function == 0:
                        data.append(str(item[1]))
                    else:
                        word[i] = item[0]
            else:
                if puncuation[w] in item and function == 0:
                    #print(f'{item[0]}\t{item[1]}\tcenter')
                    data.append(str(item[1]))

def compHex(uncomp):
    chars = ["0"]
    chars += ["g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
    comp = []
    count = 0
    for i in range(len(uncomp)):
        j = uncomp[-1 - i]
        if j == "0":
            count += 1
        else:
            if count > 0:
                k = chars[count-1]
                comp.append(k)
                count = 0
            comp.append(j)
        if i == len(uncomp) - 1 and count > 1:
            comp.append(chars[count-1])
        if count == len(chars):
            comp.append(chars[count - 1])
            count = 0
    return ''.join(comp)
            

def decompHex(comp):
    chars = ["0"]
    chars += ["g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
    decomp = []
    s = str(''.join(comp[1:]))
    for i in range(len(s)):
        j = s[-1 - i]
        if j not in chars:
            decomp.append(j)
        else:
            k = chars.index(j) + 1
            for l in range(k):
                decomp.append("0")
    #print(''.join(decomp))
    decomp = hexToBin(["h"] + decomp)
    return decomp


def hexToBin(s):
    s = str(''.join(s[1:]))
    s = int(s, 16)
    s = bin(s)[2:]
    #print(s)
    return list(s)

def genHeader(s):
    # byte 1 for size, byte 2 for char count
    headerInfo = bin(s)[2:].zfill(31) # 32 bytes, 4 bits
    headerInfo2 = bin(len(word))[2:].zfill(16) # 16 bits, 2 bytes
    headerInfo3 = "00000000" + "00000000" # 2 bytes, unused
    header = "1" + str(headerInfo) + headerInfo2 + headerInfo3
    data.append(header)
    #print(size, headerInfo, len(word), headerInfo2)

def readHeader(b):
    size = ''.join(b[1:32])
    size = int(size, 2)
    width = ''.join(b[32:48])
    width = int(width, 2)
    extra = ''.join(b[48:])
    #print(''.join(b), size, width, extra)
    return size, width

def readBin(b):
    #flags = int(''.join(b[:4]), 2)
    flags.append(b[:4]) # first 4 bits
    cur = 4
    w = 0
    hs = 64 # header size
    while cur < len(b):
        if (len(b) - cur) < hs - 1:
            break
        if int(flags[0][-1]) == 1:
            scale, count = readHeader(b[cur:cur+hs])
        else:
            scale = a
            count = (len(b) - cur)//scale
            #print(a, scale, count)
        if int(flags[0][-1]) == 0 and w == 0:
            size = scale
        if int(flags[0][-1]) == 1:
            cur += hs
        chars = 0
        #print(len(b) - cur, scale)
        while cur < len(b):
            if b[cur] == "1":
                break
            else:
                if scale < hs and len(b) - cur < scale:
                    return
                char = []
                for x in range(scale):
                    char.append(b[cur+x])
                if chars < count:
                    words[w].append(''.join(char))
                    chars += 1
                elif chars >= count:
                    puncuation.append(''.join(char))
                    chars += 1
                #print(words[w])
                cur += scale
        words.append([])
        w += 1

while True:
    try:
        function = int(input("0 for text input, 1 for binary, hex, or compressed input: "))
        break
    except:
        function = 0

if function == 0:
    text = list(input("Text input: "))
    while True:
        try:
            split = int(input("Encoding mode? 1 for standard, 0 for solid block: "))
            break
        except:
            split = 1
    if split == 1:
        splitText()
        data.append("1001")
    else:
        alphabet += spacers
        spacers = []
        data.append("1000")
        puncuation.append(" ")
        for char in text:
            words[0].append(char)
else:
    text = list(input("Encoded input: "))
    if text[0] == "h":
        text = hexToBin(text)
    if text[0] == "x":
        text = decompHex(text)
    data = ''.join(text)
    readBin(text)
    split = int(flags[0][-1])
    if split == 0:
        temp = words[0]
        #print(words)
        words = [[]]#.clear()
        for w in range(len(temp)):
            words[0].append(temp[w])
        words[0].append(''.join(puncuation))
        puncuation = [" "]
        #print(split, puncuation, "\n", words)
        alphabet += spacers
        spacers.clear()


while len(puncuation) < len(words):
    puncuation.append(" ")
w = 0
for word in words:
    if word == []:
        continue
    uniques = []
    match = []
    if split == 0:
        size = a
    else:
        size = max((len(word) * 2 + 3), 11)
    #if function == 0 and len(words) < 20:
        #print(f'\nText: {"".join(word)}{puncuation[w]}')#\nMax K value: {size//2}')
    if function == 0 and split == 1:
        genHeader(size)
    generate(size)
    w += 1

if function == 1:
    if split == 1:
        for x in range(len(puncuation)):
            words[x].append(puncuation[x])
            if puncuation[x] != ' ':
                words[x].append(' ')
            words[x] = ''.join(words[x])
            #print(words[x])
        text = ''.join(words[:len(puncuation)])
    else:
        text = ''.join(words[0][:-1])
    print('Text: ')
    print(text)

if function == 0:
    data = ''.join(data)
    hexData = hex(int(data, 2))[2:]
    print(f'\nBinary encoded data:\n{data}') # raw data
    print(f'\nHex encoded data:\nh{hexData}') # shortens text by converting to hex
    print(f'\nCompressed: \nx{compHex(hexData)}') # compress hex similar to binary, only do 0s

