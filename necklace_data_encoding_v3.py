from sympy import isprime as isP
import random
import math
import sys

# setup variables, don't touch
w = 0 			# used as a word counter
words = [[]] 		# stores words as they're used
puncuation = [] 	# stores puncuation (spacers) to match words
data = [] 		# binary data goes here
flags = [] 		# flags for data when reading encoded input
split = 0 			# true/false for splitting text up
outType = "all"	# output type, changes what gets outputed when used with command line args
outFile = "" 		# output file, if not blank then save result to file
outTxt = "" 		# output text, results of encryption
helpMsg = """Usage:
\tnecklace_data_encoding_v3.py {-e | -d} [-s] [-o output_type] {-f input_file | -t input_text} [output_file]
\tnecklace_data_encoding_v3.py -h
\tnecklace_data_encoding_v3.py 

Description:
\tA program for encrypting through the use of binary necklaces. Run without arguments for an interactive process or with arguments for more options. 

Options:
\t-e \n\t\tSet program to encrypt. Will result in encrypted text as the output.
\t-d \n\t\tSet the program to decrypt an encrypted input.
\t-s \n\t\tSet the split flag. Encryption is altered to be based on words.
\t-o \n\t\tSet the output type. \n\t-b for binary output.  \n\t-h for hex output. \n\t-c for compressed hex output.
\t-f file_input\n\t\tThe file that text will be taken from from encryption. 
\t-t text_input\n\t\tPlaintext input. Place within quotes to properly encrypt.
\toutput_file \n\t\tWrites output to file. Set to match input file to encrypt the file. 
"""

# encoding variables, all must match for encoding AND decoding or text cannot be recovered easily
a, b, c= 15, 1, 1 		# a = necklace length (when not splitting), b = starting point, c = increase for each necklace check
                                    # a should be >= 11, b needs to be low enough to fit alphabet + spacers within the necklace space generated by a
d = 8675309			# seed for shuffled alphabet
alphabet  = [ "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
alphabet += ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",]
alphabet += ["@", "#", "$", "%", "^", "&", "*", "(", ")", "-", "_", "=", "+", "[", "]", "{", "}", "\\", "|", "'", '"', "<", ">", "/", "`", "~", ":", ";", "â€¦", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]
spacers = [" ", ".", ",", "!", "?", "\t", "\n"]

# checking variables here, don't touch
aRange = ( (1/a) * sum(2**(math.gcd(i,a)) for i in range(1, a+1)) ) / abs(c)
if isP(a):
    raise ValueError("!!!\n> a is prime, please chose another value.")
if b > (2**a) or b < 1:
    raise ValueError("!!!\n> b value out of range.")
if (len(alphabet)+len(spacers)) > aRange:
    raise ValueError("!!!\n> Not enough necklace values available. ")

# code starts here

# obfuscate values, make it harder to brute force or analyze without length
def randRot(num): #ensure first bit is not a 1
    rand = num
    while(True):
        i = random.randint(0, len(num)-1)
        rand = num[i:] + num[:i]
        if rand[0] != "1":
            break
    #print(rand)
    return rand

# deobfuscate values, when length is known makes values useable
def minRot(num):
    num = str(num)
    minimum = num
    for i in range(len(num)):
        newMin = num[i:] + num[:i]
        if int(minimum) > int(newMin):
            minimum = newMin
    #print(minimum)
    return minimum

# uses spacer characters to split text into words
def splitText(): 					# split text
    w = 0 							# word counter
    p = 0 							# puncuation counter
    for char in text: 				# for each character
        #if char == "\n": 				# check if newline
            #continue 					# ignore it
        if char in spacers: 			# check if spacer
            if p == 0: 					# check if first puncuation
                ''.join(words[w]) 		# that means it was a full word
                words.append([]) 		# make space for the next word
                puncuation.append(char) 	# add the spacer to the puncuation list to match the word
                w += 1 					# add to the word counter
                p += 1 					# add to puncuation counter (ignores multiple spacers)
        else: 						# if not spacer (so found in alphabet)
            words[w].append(char) 		# add the character to the current word
            p = 0 						# reset puncuation counter

# generate necklaces
def generate(n): 									# function to generate uniques
    x = b 											# start at 1, avoid all 0s case
    while (x < 2**n): 								# for each possible number
        if len(uniques) > (len(alphabet) + len(spacers)): 	# check if enough already gnerated
            break 									# stop if enough already generated
        s = str(bin(x)[2:].zfill(n)) 						# get binary of number
        cycle = [] 									# get blank list to check rotations
        for i in range(len(s)//2 +1): 					# check rotations going both ways
            #rot = cycle[i][-1] + cycle[i][:-1] 				#slightly slower
            rot = s[i:] + s[:i] 							# rotate by i bits
            rotb = s[(len(s) - i):] + s[:(len(s) - i)] 			# reverse rotation, may help find smaller quicker
            cycle.append(rot) 							# add forward rotation
            cycle.append(rotb)							# add reverse rotation
            if rot < s or rotb < s : 						# if rotation found that is smaller
                break 									# stop searching
        if min(cycle) == s : 							# if the number is already minimum
            uniques.append(s) 							# add to the list
            #print(f'\t{s}') 							# print results (slow)
        x += 2 * c 									# count odds, halves time
    # match each character to a necklace
    x=0
    #print(f'Alphabet {w}: ')
    for letter in alphabet:
        #print(f'\t{letter}\t{uniques[x]}')
        match.append([letter, uniques[x]])
        x+=1
    if function == 0:
        for spacer in spacers:
            match.append([spacer, uniques[x]])
            x+=1
    else:
        spc = []
        for spacer in spacers:
            spc.append([spacer, uniques[x]])
            x+=1
            for item in spc:
                if puncuation[w] in item:
                    puncuation[w] = item[0]
                    if function == 0:
                        data.append(randRot(str(item[1])))
    # decrypt, match neclace to letter
    for item in match:
        for i in range(len(word)):
            if word[i] in item:
                word[i] = item[0]
    # encrypt, go through text and convert characters to binary from necklace
    if function == 0:
        l = 1
    else:
        l = 0 #
    for i in range(len(word) + l):
        for item in match:
            if i < len(word):
                if word[i] in item:
                    #print(f'{item[0]}\t{item[1]}\tK = {i+1}')
                    if function == 0:
                        data.append(randRot(str(item[1])))
                    else:
                        word[i] = item[0]
            else:
                if puncuation[w] in item and function == 0:
                    #print(f'{item[0]}\t{item[1]}\tcenter')
                    data.append(randRot(str(item[1])))

# compress hex data by converting 0s
def compHex(uncomp):
    chars = ["0"]
    chars += ["g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
    comp = []
    count = 0
    for i in range(len(uncomp)):
        j = uncomp[-1 - i]
        if j == "0":
            count += 1
        else:
            if count > 0:
                k = chars[count-1]
                comp.append(k)
                count = 0
            comp.append(j)
        if i == len(uncomp) - 1 and count > 1:
            comp.append(chars[count-1])
        if count == len(chars):
            comp.append(chars[count - 1])
            count = 0
    return ''.join(comp)
            
# converts characters back into 0s
def decompHex(comp):
    chars = ["0"]
    chars += ["g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
    decomp = []
    s = str(''.join(comp[1:]))
    for i in range(len(s)):
        j = s[-1 - i]
        if j not in chars:
            decomp.append(j)
        else:
            k = chars.index(j) + 1
            for l in range(k):
                decomp.append("0")
    #print(''.join(decomp))
    decomp = hexToBin(["h"] + decomp)
    return decomp

# convert hex into binary
def hexToBin(s):
    s = str(''.join(s[1:]))
    s = int(s, 16)
    s = bin(s)[2:]
    #print(s)
    return list(s)

# create a header for each text section when splitting while encrypting
def genHeader(s):
    # byte 1 for size, byte 2 for char count
    headerInfo = bin(s)[2:].zfill(31) # 32 bytes, 4 bits
    headerInfo2 = bin(len(word))[2:].zfill(16) # 16 bits, 2 bytes
    headerInfo3 = "00000000" + "00000000" # 2 bytes, unused
    header = "1" + str(headerInfo) + headerInfo2 + headerInfo3
    data.append(header)
    #print(size, headerInfo, len(word), headerInfo2)

# reads data from header of split text while decrypting
def readHeader(b):
    size = ''.join(b[1:32])
    size = int(size, 2)
    width = ''.join(b[32:48])
    width = int(width, 2)
    extra = ''.join(b[48:])
    #print(''.join(b), size, width, extra)
    return size, width

# read data to decrypt
def readBin(b):
    #flags = int(''.join(b[:4]), 2)
    flags.append(b[:4]) # first 4 bits
    cur = 4
    w = 0
    hs = 64 # header size
    while cur < len(b):
        if (len(b) - cur) < hs - 1:
            break
        if int(flags[0][-1]) == 1:
            scale, count = readHeader(b[cur:cur+hs])
        else:
            scale = a
            count = (len(b) - cur)//scale
            #print(a, scale, count)
        if int(flags[0][-1]) == 0 and w == 0:
            size = scale
        if int(flags[0][-1]) == 1:
            cur += hs
        chars = 0
        #print(len(b) - cur, scale)
        while cur < len(b):
            if b[cur] == "1":
                break
            else:
                if scale < hs and len(b) - cur < scale:
                    return
                char = []
                for x in range(scale):
                    char.append(b[cur+x])
                if chars < count:
                    words[w].append(minRot(''.join(char)))
                    chars += 1
                elif chars >= count:
                    puncuation.append(minRot(''.join(char)))
                    chars += 1
                #print(words[w])
                cur += scale
        words.append([])
        w += 1

# -------------------------------------------------
# ------------------ main -------------------------
# -------------------------------------------------

#print(len(sys.argv), sys.argv)
if len(sys.argv) > 1:    
    if ("-h" in sys.argv or "-help" in sys.argv): # help message requested
        print(helpMsg)
        sys.exit()
    
    if (len(sys.argv) < 4):
        raise ValueError("Too few arguments, please see -h for usage.")
    
    if "-s" in sys.argv: # split flag
        split = 1
    
    if "-e" in sys.argv: # encrypt
        function = 0
    elif "-d" in sys.argv: # decrypt
        function = 1
    else:
        raise ValueError("Must specify encryption or decryption.")
    
    if "-t" in sys.argv:
        text = list(sys.argv[sys.argv.index("-t") + 1])
    elif "-f" in sys.argv:
        with open(sys.argv[sys.argv.index("-f") + 1], "r") as file:
            text = list(file.read())
    else:
        raise ValueError("Must specify input type.")
    
    if "-o" in sys.argv and function == 0:
        output = sys.argv.index("-o")
        outType = sys.argv[output+1]
        if outType not in ["all", "-h", "h", "hex", "hexadecimal", "-c", "c", "comp", "compressed",  "-b", "b", "bin", "binary"]:
            raise ValueError("Incorrect output type. Must be b (bin), h (hex), c (compressed), or excluded for all.")
    
    if (sys.argv.index("-f") + 1) < (len(sys.argv) -1):
        outFile = sys.argv[-1]
    
else:
    # determine if encrypting or decrypting
    while True:
        try:
            function = int(input("0 for text input, 1 for binary, hex, or compressed input: "))
            break
        except:
            function = 0
    # get text input to encode if not provided in command line
    if function == 0:
        text = list(input("Text input: "))
        # determine if text should be split
        while True:
            try:
                split = int(input("Encoding mode? 1 for standard, 0 for solid block: "))
                break
            except:
                split = 1
    else: # if decrypting
        text = list(input("Encoded input: "))

# handle data to be used based on options
if function == 0:
    # encode setup
    if split == 1:
        splitText()
        data.append("1001")
    else:
        alphabet += spacers
        spacers = []
        data.append("1000")
        # if not splitting, format properly
        puncuation.append(" ")
        for char in text:
            words[0].append(char)
else: # decode setup
    # determine message type and convert to binary if necessary
    if text[0] == "h":
        text = hexToBin(text)
    if text[0] == "x":
        text = decompHex(text)
    data = ''.join(text)
    # read the message binary and convert it into usable data
    readBin(text)
    # determine if text is split, make adjustments to handle if not
    split = int(flags[0][-1])
    if split == 0:
        temp = words[0]
        #print(words)
        words = [[]]#.clear()
        for w in range(len(temp)):
            words[0].append(temp[w])
        words[0].append(''.join(puncuation))
        puncuation = [" "]
        #print(split, puncuation, "\n", words)
        alphabet += spacers
        spacers.clear()

# use alphabet seed
random.seed(d)
random.shuffle(alphabet) #shuffle alphabet acording to seed
random.seed(None)

# ensure no formatting errors based on puncuation
while len(puncuation) < len(words):
    puncuation.append(" ")

# run through the text to encode or decode
w = 0
for word in words:
    if word == []:
        continue
    uniques = []
    match = []
    if split == 0: # use length value if not splitting
        size = a
    else:
        size = max((len(word) * 2 + 3), 11)
    #if function == 0 and len(words) < 20:
        #print(f'\nText: {"".join(word)}{puncuation[w]}')#\nMax K value: {size//2}')
    if function == 0 and split == 1: # generate header for each word if encoding and splitting
        genHeader(size)
    generate(size) # actual encryption/decryption function
    w += 1

# if decrypting, show decrypted text
if function == 1:
    # format properly based on split or not split
    if split == 1: 
        for x in range(len(puncuation)):
            words[x].append(puncuation[x])
            if puncuation[x] != ' ':
                words[x].append(' ')
            words[x] = ''.join(words[x])
            #print(words[x])
        text = ''.join(words[:len(puncuation)])
    else:
        text = ''.join(words[0][:-1])
    if len(sys.argv) < 2:
        outTxt += 'Text: '
    outTxt += text

# add junk data if encoding and not splitting to deter factoring
if function == 0 and split == 0:
    x = random.randint(0, a-1)
    for i in range(x):
        data.append(str(random.randint(0, 1)))

# if encoding, display encoded results
if function == 0:
    data = ''.join(data)
    hexData = hex(int(data, 2))[2:]
    if len(sys.argv) < 2 and outType != "all":
        outTxt += "\n"
    if outType in ["all", "-b", "b", "bin", "binary"]:
        if outType == "all":
            outTxt += "\nBinary encoded data:" # raw data
        outTxt += data # raw data
    if outType in ["all", "-h", "h", "hex", "hexadecimal"]:
        if outType == "all":
            outTxt += "\nHex encoded data:" # shortens text by converting to hex
        outTxt += f'h{hexData}' # shortens text by converting to hex
    if outType in ["all", "-c", "c", "comp", "compressed"]:
        if outType == "all":
            outTxt += "\nCompressed:" # compress hex on 0s
        outTxt += f'x{compHex(hexData)}' # compress hex on 0s

if outFile == "":
    print(outTxt)
else:
    with open(outFile, "w") as file:
        file.write(outTxt)

